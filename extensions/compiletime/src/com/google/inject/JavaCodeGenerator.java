/**
 * Copyright (C) 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.google.inject;

import java.io.*;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

/**
 * @author jessewilson@google.com (Jesse Wilson)
 */
/* public */ class JavaCodeGenerator {

  private final Writer writer;
  private final String packageName;
  private int indent = 0;

  /**
   * Imported classes, by their simple name. If multiple classes with the same
   * simplename have been imported, the fully qualified names will be used for
   * all but one of those classes.
   */
  private final Map<String, Class<?>> importedClasses = new HashMap<String, Class<?>>();

  private JavaCodeGenerator(Writer writer, String packageName) {
    this.writer = writer;
    this.packageName = packageName;
  }

  public static JavaCodeGenerator open(File generatedSourceDirectory,
      String packageName, String topLevelClassName) throws IOException {
    File directory = generatedSourceDirectory;
    for (String packagePart : packageName.split("\\.")) {
      directory = new File(directory, packagePart);
    }
    directory.mkdirs();
    File sourceFile = new File(directory, topLevelClassName + ".java");
    return new JavaCodeGenerator(
        new OutputStreamWriter(new FileOutputStream(sourceFile), "ISO-8859-1"), packageName);
  }

  public void writePackageHeader() throws IOException {
    writeLine("// Generated by Guice. Do not edit!");
    writeLine("package %s;", packageName);
    writeLine();
  }

  public void writeImport(Type type) throws IOException {
    if (!(type instanceof Class)) {
      throw new UnsupportedOperationException();
    }

    Class<?> clas = (Class<?>) type;

    if (importedClasses.containsKey(clas.getSimpleName())) {
      return;
    }

    if (!"java.lang".equals(clas.getPackage().getName())) {
      writeLine("import %s;", typeName(type));
    }
    importedClasses.put(clas.getSimpleName(), clas);
  }

  public String typeName(Type type) {
    if (type instanceof Class<?>) {
      Class<?> clas = (Class<?>) type;
      if (importedClasses.get(clas.getSimpleName()) == type) {
        return clas.getSimpleName();
      }
      StringBuilder result = new StringBuilder();
      result.append(clas.getPackage().getName());
      for (Class<?> enclosing = clas.getEnclosingClass(); enclosing != null;
          enclosing = enclosing.getEnclosingClass()) {
        result.append(".").append(enclosing.getSimpleName());
      }
      result.append(".").append(clas.getSimpleName());
      return result.toString();

    } else {
      throw new UnsupportedOperationException();
    }
  }

  private Object[] processArgs(Object... args) {
    args = args.clone();
    for (int i = 0; i < args.length; i++) {
      if (args[i] instanceof Class<?>) {
        args[i] = typeName((Class<?>) args[i]);
      }
    }
    return args;
  }

  public JavaCodeGenerator writeLine(String format, Object... args) throws IOException {
    for (int i = 0; i < indent; i++) {
      writer.append("  ");
    }
    writer.append(String.format(format, processArgs(args)));
    writeLine();
    return this;
  }

  public JavaCodeGenerator openScope(String format, Object... args) throws IOException {
    writeLine(format, args);
    indent++;
    return this;
  }

  public JavaCodeGenerator closeScope(String format, Object... args) throws IOException {
    indent--;
    return writeLine(format, args);
  }

  public JavaCodeGenerator writeLine() throws IOException {
    writer.append("\n");
    return this;
  }

  public void close() throws IOException {
    writer.close();
  }
}
